<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Apothéose Helper</title>
  <link rel="stylesheet" href="reset.css">
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div class="site-container">
    <h1 class="main-title">Apothéose Helper</h1>

    <nav>
      <a href="#conseils-generaux">Conseils généraux</a>
      <a href="#api-or-not-api">API or not API ?</a>
      <a href="#authentification">Authentification</a>
      <a href="#cors">CORS</a>
      <a href="#emails">Emails</a>
      <a href="#upload-image">Upload d'images</a>
      <a href="#temps-reel">Temps réel</a>
    </nav>
    <p>
      Tu retrouveras ici toutes les recommandations pour une bonne apothéose. Tu dois quasi les connaître par coeur et
      comprendre pourquoi ce sont des bonnes recommandations.
    </p>

    <h2 class="secondary-title" id="conseils-generaux">
      <a href="#conseils-generaux"># Conseils généraux</a>
    </h2>
    <div class="content">
      <p>Voici quelques conseils généraux importants à prendre ne compte.</p>
      <h3 class="tertiary-title">Le partage du travail</h3>
      <p>
        Il peut être compliqué de savoir comment travailler à plusieurs sur un projet. Surtout quand des fonctionnalités dépendent d'autres. Par exemple, vous avez besoin que le projet soit installé et configuré pour faire votre homepage (éhé sacré cerveau). Et bien dans ces cas là, mettez vous à deux sur la fonctionnalité, en pair programming. Quelques moments du genre : <em>installation</em>, <em>création</em> <em>de l'entité des user</em>, <em>installation de la première fixture</em>, <em>création de l'authentification</em>, <em>création du store</em> etc.
      </p>
      <h3 class="tertiary-title">
        Kikifé ? Le back ou le front ?
      </h3>
      <p>
        Souvent, vous vous posez la question de si c'est le back ou le front qui doit faire telle ou telle chose. Pour obtenir la réponse il faut garder en tête que <strong>le back gère la donnée et que le front affiche la donnée.</strong> <br> 
        Il faut aussi garder en tête que c'est tout ce qui est fait côté front peut être analysé et trouvé par des "hacker". </br />
        L'application doit être performante.
        <br />
        J'ai vu trop de fois des projets ou on récupère 10000 entrée de la bdd via un endpoint d'API du back pour l'envoyer au front et ensuite faire une pagination côté front pour afficher 10 entrées par 10 entrées. C'est une mauvaise pratique. Le back doit gérer la pagination et ne renvoyer que les 10 entrées pour la page demandée à chaque fois <br />
      </p>
      <p>
        Si je créé un jeu par exemple, les algorithmes doivent être côté back. Le front ne doit faire que DEMANDER des choses. "Je demande à modifier cette donnée", "Je veux bouger à droite", Le back doit répondre à ces demandes. "Ok, je modifie cette donnée", "Non tu peux pas bouger à droite".
        <br />
        Si le front a la capacité de décider de ces choses là on peut très facilement contourner l'application. 
        <br />
        C'est quasi tout le temps valable. Le front doit faire le minimum d'algo. Si vous avez un doute, demandez à votre helper d'apothéose préféré ;)
      </p>
      <h3 class="tertiary-title">Les données</h3>
      <p>
        En phase de développement, on se fiche totalement des données présentes en BDD. Autrement dit, on n'a besoin
        d'aucun vrai contenu pour développer, que des données de test. Côté Symfony il faudra mettre en place des
        fixtures dès le début du projet, dès que des entités seront en place. <strong>Interdit de se passer les bases de
          données par export SQL</strong>, c'est contraire au principe de migration et peut générer des erreurs. <br />
        Quand je récupère un projet Symfony, il doit être fonctionnel avec des datas et utilisateurs de test après avoir
        fait :
      </p>
      <p class="warning">
        - <code>composer install</code><br />
        - Modification du .env pour la connexion à la BDD<br /> (et autres spécifiés dans le .env.example) <br />
        - <code>bin/console doctrine:database:create</code> <br />
        - <code>bin/console doctrine:migrations:migrate</code><br />
        - <code>bin/console doctrine:fixtures:load</code><br />
      </p>
      <p>
        Côté Directus, vous avez une bdd partagée, et pas de fixtures possible. Mais la BDD va peut être changer pendant
        le projet, alors aucune vraie donnée dans la BDD avant la démo de projet. Car vous risquez de devoir modifier la
        structure et donc complètement réécrire toutes les données que vous auriez rentrées.
      </p>
      <p>
        De manière globale, 10/20 entrées par entités suffisent pour développer.
      </p>
      <h3 class="tertiary-title">Git</h3>
      <p>
        Organisation conseillée : <br />
        - <code>master</code>: c'est la branche de référence pour la production. Tout doit être fonctionnel dessus.
        Uniquement la branche de <code>dev</code> à le droit d'être mergée dessus, quand elle n'a plus d'erreur. <br />
        - <code>dev</code>: c'est la branche de référence pour le développement, toute fonctionnalité terminée doit être
        mergée dans cette branche après avoir été testée.<br />
        - <code>brancheFonctionnalité1</code>: une branche à chaque fois qu'on commence une fonctionnalité (header,
        homepage, connexion, contact-page) etc ... <br />
        - <code>brancheFonctionnalité2</code><br />
        - etc.<br />
      </p>
      <p>Une nouvelle fonctionnalité à développer ? <code>git checkout -b maNouvelleBranche</code></p>
      <p>Noms de commits: <br />
        - <code>git commit -m "feat: add contact page"</code> <br />
        - <code>git commit -m "fix: login issue when no email"</code> <br />
        - <code>git commit -m "refacto: better homepage styling "</code> <br />
        - <code>git commit -m "docs: addded documentation for image upload"</code> <br />
        - <code>git commit -m "wip: MailHog configuration not finished"</code> <br />
      </p>
      <p>
        Pour merger, soit vous le fait en local et vous poussez ensuite sur GitHub, soit vous faites une pull request sur GitHub. Au choix. La deuxième est plus sympa pour montrer aux autres ce que vous avez fait avant de mettre sur dev. Une fois votre fonctionnalité terminée, supprimez votre branche localement et sur GitHub, et repartez sur une nouvelle depuis dev.
      </p>
    </div>


    <h2 class="secondary-title" id="api-or-not-api">
      <a href="#api-or-not-api"># API or not API ?</a>
    </h2>
    <div class="content">
      <h3 class="tertiary-title">API</h3>

      <p>
        Les projets <strong>React/Symfony</strong> et <strong>Svelte/Directus</strong> sont des projets qui nécessitent
        d'être fait en mode <strong>API JSON</strong>.
        <br />
        Il y aura de préférence un repository pour le back et un pour le front.
      </p>
      <p>Pour Directus, pas de repository étant donné qu'il s'agit d'un site distant. Il permet de créer une base de
        donnée et automatiquement des endpoints d'API via une interface en ligne.</p>
      <p>Pour Symfony cela signifie donc que de manière basique le projet back n'affichera pas de html. Il ne retournera
        que du json. Pour autant, il faudra certainement un back-office qui lui sera donc fait en twig.</p>
      <p>Côté Svelte, pas besoin de coder un back-office particulier, Directus gérant cette partie.</p>

      <h3 class="tertiary-title">NOT API</h3>
      <p>Si l'équipe n'est composée que de Symfony, le projet ne devra donc pas être fait en mode API. On code donc de
        manière classique avec des templates twig.</p>
    </div>

    <h2 class="secondary-title" id="authentification">
      <a href="#authentification"># Authentification</a>
    </h2>
    <div class="content">
      <h3 class="tertiary-title">Symfony/React</h3>
      <p>
        Il faudra passer par le bundle <a href="https://github.com/lexik/LexikJWTAuthenticationBundle" target="_blank">
          Lexik JWT
          Authentication</a>. Il s'occupe de tout et il faut simplement avoir déjà géré l'ajout d'utilisateur à votre
        projet. Assurez-vous d'avoir utilisé la commande <code>bin/console make:user</code> pour avoir une base
        correcte.<br />
        Suivez la documentation sur le GitHub pas à pas et il ne devrait pas y avoir de soucis.
        <br />
      </p>
      <p class="warning">
        Attention, quand vous testerez avec Insomnia, Postman ou autre ça marchera sans avoir à se soucier des CORS. Dès
        que vous voudrez tester avec le front, il faudra penser à configurer les CORS. Voir la section <a
          href="#cors">CORS</a>.
      </p>
      <h3 class="tertiary-title">Svelte/Directus</h3>
      <p>
        Ici tout est géré par Directus déjà. Vous avez donc les endpoints nécessaire à la connexion spécifiés dans la <a
          href="https://docs.directus.io/reference/authentication.html" target="_blank">doc ici</a>. Pas de soucis de
        CORS.
      </p>
      <h3 class="tertiary-title">Full Symfony</h3>
      <p>
        Pas d'API donc vous pouvez passer par l'authentification avec Symfony. Le plus simple reste d'utiliser la
        commande <code>bin/console make:auth</code> après la commande <code>bin/console make:user</code>et de suivre la
        doc. Gardez bien en tête qu'il faut quand même être capable de comprendre les fichiers générés !
      </p>
    </div>

    <h2 class="secondary-title" id="cors">
      <a href="#cors"># CORS</a>
    </h2>
    <div class="content">
      <h3 class="tertiary-title">C'est quoi et ça concerne qui ? </h3>
      <p>
        CORS signifie <strong>Cross Origin Resource Sharing</strong>. C'est un mécanisme qui permet à un serveur de
        restreindre les ressources qu'il met à disposition d'une page web. Cela permet d'éviter les problèmes de
        sécurité (mais pas vraiment, j'y reviens).<br />
        En gros, si vous avez un serveur qui tourne sur <code>localhost:8000</code> et que vous voulez faire des
        requêtes depuis votre front qui tourne sur <code>localhost:3000</code>, il faudra configurer les CORS pour
        autoriser les requêtes car les deux projets sont sur des ports différents. Ça serait pareil avec des noms de
        domaines différents.
      </p>
      <p>
        Pour spécifier les ports/domaines qu'on autorise, on pourrait ajouter un header HTTP spécifique, mais on préfère
        utiliser une librairie qui va nous faciliter la tâche.
        <br /> Concrètement il s'agirait d'ajouter un header HTTP <code>Access-Control-Allow-Origin</code>
      </p>
      <p class="warning">
        <em>"Mais pourquoi j'ai pas le soucis avec Insomnia/Postman ?"</em> => Parce que ces outils ne sont pas soumis
        aux CORS. En fait ce n'est pas directement le serveur qui bloque un nom de domaine ou qui n'autorise qu'une nom
        de domaine. C'est une implémentation dans le navigateur qui voit que le serveur lui met un en tête pour
        autoriser ou non une origine. Donc si le client qui demande une ressource qui n'est pas autorisé, le navigateur
        bloque la requête. Insomnia ou Postman ne font pas ça.
        <br />
        Avec cette explication, vous devez aussi comprendre que les CORS, à part être ennuyeux, ne protègent pas grand
        chose ... étant donné qu'on peut très bien appeler des endpoint api via des outils comme Insomnia ou Postman ou
        même des script en ligne de commande. On va dire que le seul intérêt c'est que quelqu'un ne pourra pas coder un
        front qui se sert de notre API et le mettre en ligne sur son propre domaine.
      </p>

      <h3 class="tertiary-title">Symfony/React</h3>
      <p>
        Si vous avez un projet Symfony/React, il faudra configurer les CORS. Pour cela, il faut installer le bundle <a
          href="https://github.com/nelmio/NelmioCorsBundle" target="_blank">NelmioCorsBundle</a>.<br />
        Suivez la doc et tout devrait bien se passer.
      </p>
      <p>
        Pour le début je vous conseil de laisser tout ouvert et définir <code>allow_origin: ["*"]</code> et
        <code>allow_headers: ["*"]</code> dans le fichier <code>nelmio_cors.yaml</code>.<br />
        Une fois en prod, vous pourrez changer le <code>allow_origin</code> pour n'autoriser que le domaine de votre
        frontend.
      </p>
      <p class="warning">Astuce: Si vous voulez testez que les CORS marchent sans avoir à solliciter le front ou devoir
        mettre le projet en ligne. Vous pouvez vous créer une mini app dans un fichier <code>index.html</code> qui aura
        pour seul but de faire une requête <code>fetch()</code> vers un endpoint de votre projet Symfony.</p>
    </div>

    <h2 class="secondary-title" id="emails">
      <a href="#emails"># Emails</a>
    </h2>
    <div class="content">
      <h3 class="tertiary-title">Tous projets</h3>
      <p>
        L'envoi d'email n'est pas toujours simple à configurer et il faudrait avoir un serveur SMTP pour pouvoir envoyer
        de vraies email. Pendant la période de développement, on s'en fiche un peu d'envoyer de vrais emails, mais on
        veut pouvoir tester si ils partent bien quand même. On va donc utiliser des outils pour intercepter les
        tentative d'envoi d'email et les afficher dans des fausses boites mails. Comme ça on sait que si ça part, on
        n'aura plus qu'à brancher au serveur SMTP pour que les emails s'envoient en prod.
      </p>
      <p>Il existe aussi d'autres moyens qu'on décrit plus bas.</p>
      <h3 class="tertiary-title">Intercepteurs d'emails</h3>
      <p>
        Il existe plusieurs outils pour intercepter les emails. On en liste 2 ici :
      </p>
      <p>
        <a href="https://github.com/mailhog/MailHog" target="_blank">MailHog</a> permet d'intercepter les emails envoyés
        sur le port 1025 avec le protocol SMTP. Cet outil viens avec une
        fausse boite de reception en local, accessible à l'adresse <a href="http://0.0.0.0:8025/"
          target="_blank">http://0.0.0.0:8025</a>
        une fois mailhog lancé. Pour
        installer et lancer cet outil, c'est assez simple :

      <p class="warning">
        1. <code>sudo apt-get -y install golang-go</code><br />
        2. <code>go get github.com/mailhog/MailHog</code><br />
        3. <code>~/go/bin/MailHog</code><br />
      </p>

      On accède à la "boite mail" sur <a href="http://0.0.0.0:8025/" target="_blank">http://0.0.0.0:8025</a> et on envoi
      les mails sur <code>smtp://localhost:1025</code>, c'est tout
      !
      </p>
      <p>
        <a href="https://mailtrap.io/" target="_blank">MailTrap</a> de son côté, ne nécessite pas d'installation sur ta
        machine. C'est un service en ligne via lequel on
        envoi nos emails. La boite de réception est également accessible via le site de MailTrap. <a
          href="https://mailtrap.io/register/signup?ref=pricing_table_summary" target="_blank">Se créer un compte
          ici</a>
        puis dans "My Inbox" sélectionner l'intégration voulue par rapport à ta techno. MailTrap te fournit la
        configuration à copier/coller dans ton projet. Tu n'as plus qu'à tester l'envoi d'un mail.
      </p>
      <h3 class="tertiary-title">Qui envoi les mails ?</h3>
      <p>
        Pour un projet <strong>Symfony/React</strong> c'est <strong>Symfony</strong> qui envoi les mails.
        Pour un projet <strong>Directus/Svelte</strong> c'est <strong>Directus</strong> qui envoi les mails, voir la
        marche à suivre ici : <a href="https://learndirectus.com/how-to-send-an-email"
          target="_blank">https://learndirectus.com/how-to-send-an-email</a>
      </p>
      <p>
        Par exemple, si un utilisateur soumet un formulaire d'inscription côté React, l'application React enverra un
        appel API en POST au backend Symfony. Symfony fera l'ajout de l'utilisateur en BDD puis enverra un email de
        confirmation.
      </p>
      <p class="warning">
        Pour Symfony pensez à commenter la ligne :
        <code>Symfony\Component\Mailer\Messenger\SendEmailMessage: async</code> dans
        <code>config/packages/messenger.yaml</code>, sinon Symfony enverra tous tes mails en BDD sans les envoyer à
        l'utilisateur.
      </p>
      <h3 class="tertiary-title">Ok mais je veux envoyer un vrai email moi !</h3>
      <p>
        Alors tu peux par exemple utiliser ton compte gmail comme serveur SMTP, pour ça il faudra que tu définisse <a
          href="https://support.google.com/mail/answer/185833?hl=fr" target="_blank">un mot de passe d'application pour
          ton compte</a>. On te conseil tout de mêmee de créer un nouveau compte gmail, spécifique à ton projet, pour
        éviter tout risque de sécurité avec ton compte perso. Ensuite, rends toi sur la documentation qui concerne ta
        techno pour l'utiliser.
      </p>
      <p>
        Par exemple <a href="https://symfony.com/doc/7.1/mailer.html" target="_blank">Symfony avec cette méthode</a>,
        les emails seront vraiment envoyés sur les boites mails des destinataires.
      </p>
      <p class="warning">
        Puis si tu galères, contact ton helper d'apothéose préféré ;)
      </p>
    </div>

    <h2 class="secondary-title" id="upload-image">
      <a href="#upload-image"># Upload d'images</a>
    </h2>
    <div class="content">
      <h3 class="tertiary-title">Symfony/React</h3>
      <p>Si les images doivent être envoyés par le front React, il y a plusieurs possibilités mais on va ici en décrire
        une seule, la plus "simple" à mettre en place. Si c'est juste des uploads côté back-office, donc côté Symfony,
        voir la section "Symfony" plus bas.</p>
      <p>
        Pour envoyer une image en même temps que d'autre données en JSON on n'a pas d'autres choix que transformer notre
        image en texte. Pour ça on utilise le format <a href="https://fr.wikipedia.org/wiki/Base64"
          target="_blank">Base64</a>.<br />
      </p>
      <p>
        Côté Symfony, il faut donc développer un endpoint capable classique qui récupère des données en POST. Mais vu
        que l'image qu'il va récupérer n'est qu'une chaîne de caractère, il va falloir être capable de recréer une image
        avec.
        Soit directement dans le controller, soit dans un service. Si vous voulez des pistes sur comment faire ça, cette
        issue sur StackOverflow aide beaucoup : <a
          href="https://stackoverflow.com/questions/55124010/base64-image-to-image-file-with-symfony-and-vichuploader" target="_blank">https://stackoverflow.com/questions/55124010/base64-image-to-image-file-with-symfony-and-vichuploader</a>.
        Ici VichUploader ne nous intéresse pas, ce sont seulement les deux services et comment ils sont utilisés qui
        nous intéresse. On vous laisse essayer d'adapter ça de votre côté ;)
      </p>
      <p>
        Pour tester avec Insomnia, Postman ou autre, utilisez <a
          href="https://www.base64-image.de/" target="_blank">https://www.base64-image.de/</a> pour convertir une image en base64 et
        copier/coller le résultat dans le body de votre requête.
      </p>
      <p>Maintenant que c'est fait côté Symfony. Il ne reste plus qu'à gérer côté React.Vous avez plusieurs pistes ici :
        <a
          href="https://stackoverflow.com/questions/47176280/how-to-convert-files-to-base64-in-react" target="_blank">https://stackoverflow.com/questions/47176280/how-to-convert-files-to-base64-in-react</a>
        soit en codant la fonctionnalité vous même soit en utilisant des librairies toutes faites. On vous laisse tenter
        ! <br />
        Envoyez donc votre image en base64 dans le body de votre requête POST et ça devrait marcher comme sur des
        roulettes.
      </p>
      <h3 class="tertiary-title">Directus/Svelte</h3>
      <p>
        Vous pouvez regarder la doc ici <a href="https://docs.directus.io/reference/files.html"
          target="_blank">https://docs.directus.io/reference/files.html</a> qui indique comment upload des fichiers via
        l'API. Pas de base64 ici, mais du <code>multipart/form-data</code>. Pour envoyer vos données de formulaire pour
        l'ajout d'un article de blog il faudra le faire en deux fois donc. Une première requête qui envoi les données
        textuelles (titre, contenu, catégories), et une autre qui envoi seulement l'image en la liant à l'article de
        blog. L'id de l'article ayant été récupéré à la fin de la requête précédente.
      </p>

      <h3 class="tertiary-title">Symfony</h3>
      <p>
        Pour tout upload d'image directement depuis Symfony vous avez des indications ici : <a
          href="https://symfony.com/doc/current/controller/upload_file.html" target="_blank">https://symfony.com/doc/current/controller/upload_file.html</a>.
        Ça propose dès le début de plutôt utiliser <a
          href="https://github.com/dustin10/VichUploaderBundle" target="_blank">https://github.com/dustin10/VichUploaderBundle</a>
        plutôt que d'essayer de tout faire à la main. Tout étant précisément indiqué dans la doc, on ne détaillera pas
        plus la manip ici.
    </div>

    <h2 class="secondary-title" id="temps-reel">
      <a href="#temps-reel"># Temps réel</a>
    </h2>
    <div class="content">
      <h3 class="tertiary-title">
        Je veux des fonctionnalités en temps réel !
      </h3>
      <p>
        Par exemple, je voudrais un système de chat ou de notifications.
        <br /> 
        Pour ça le plus simple c'est d'utiliser <a href="https://socket.io/" target="blank">Socket.io</a>. C'est une librairie qui permet de faire du temps réel. C'est du NodeJS, mais la prise en main n'est pas trop complexe et la création d'un chat (sans stockage des messages) se fait rapidement.
      </p>
      <p>
        Socket.io doit donc être installé sur un serveur Node. Un serveur Node enfait c'est juste un fichier index.js qu'on va lancer avec la commande `node index.js`. Dans ce fichier on va utiliser la librairie express pour créer un serveur HTTP. Et on va utiliser Socket.io pour créer un serveur de websocket. C'est ce serveur de websocket qui va permettre de faire du temps réel.
      </p>
      <p class="warning">
        Exemple : <br />
        - Mon utilisateur soumet un form pour envoyer un message dans un chat <br />
        - Le front emet un évènement avec un label (`newMessage` par exemple) avec le contenu du message vers le serveur de websocket <br />
        - Le serveur de websocket reçoit l'évènement `newMessage` et l'envoi à tous les utilisateurs concernés <br />
        - (optionnel) Le serveur de websocket envoi une requête API au back pour enregistrer le message en BDD
        - Le front reçoit l'évènement `newMessage` et l'affiche dans le chat<br />
        - (optionnel) Quand l'utilisateur recharge la page, le front va faire une requête API pour récupérer tous les messages en BDD et les afficher <br />
      </p>
    </div>
  </div>


</body>

</html>